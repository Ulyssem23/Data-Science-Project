import numpy as np
from scipy.sparse import csr_matrix


class matrix: #create a class
    def __init__(self, matrix1):
        #store the matrix1 as an attribute of the class
        self.matrix1 = np.array(matrix1)

#create methods for matrix operations  

    def MM(self, matrix2):
        #convert the matrix2 to a NumPy array
        self.matrix2 = np.array(matrix2)
        #perform matrix multiplication using np.dot
        multiplication = np.dot(self.matrix1, self.matrix2)
        #return the result of the multiplication
        return multiplication
        
    def MV(self, vector):
        #convert the vector to a NumPy array
        vector = np.array(vector)
        #check if the vector is a 1D array and has the correct dimension, vector.ndim != 1:checks if the vector's dimension is not equal to 1, vector.shape[0] != self.matrix1.shape[1]:checks if the length of the vector is not equal to the number of columns
        if vector.ndim != 1 or vector.shape[0] != self.matrix1.shape[1]:
            #raise an error if the vector's dimension is incorrect
            raise ValueError("Vector's dimension is incorrect")
        #perform matrix-vector multiplication using np.dot
        multiplication = np.dot(self.matrix1, vector)
        #return the result of the multiplication
        return multiplication

    def ADD(self, matrix3):
        self.matrix3 = np.array(matrix3)
        addition = np.add(self.matrix1, self.matrix3)
        return addition
    
    def SUB(self, matrix4):
        self.matrix4 = np.array(matrix4)
        subtraction = np.subtract(self.matrix1, self.matrix4)
        return subtraction
    
class denseMatrix(matrix):
    def __init__(self, matrix1):
        matrix.__init__(self, matrix1)

class sparseMatrix(matrix):
    def __init__(self, matrix1):
        matrix.__init__(self, matrix1)
    def sparse(self):
        sparseM = csr_matrix(self.matrix1)
        return sparseM

